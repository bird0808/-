# Collection

集合主要有两类，包括**单列集合**、**双列集合**。

Collection接口有两个重要的子接口：List、Set。它们实现的都是单列集合

Collection实现子类可以存放多个元素，每个元素可以是Object，Collection接口没有直接实现的子类，是通过它的子接口List和Set来实现的。

Collection接口遍历元素：

- 方式一：使用迭代器，通过iterator()方法获取迭代器，所有实现了Collection接口的类都有这个方法。

    ```java
    public static void main(String[] args) {
        List<Integer> list=new ArrayList<>();
        list.add(4);
        list.add(2);
        list.add(3);
        list.add(4);
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
    ```
    
- 方式二：增强for循环，它底层实际上也是迭代器

    ```java
    public static void main(String[] args) {
        List<Integer> list=new ArrayList<>();
        list.add(4);
        list.add(2);
        list.add(3);
        list.add(4);
        for (Integer integer : list) {
            System.out.println(integer);
        }
    }
    ```

- 方式三：普通for循环

    ```java
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        list.add("xue");
        list.add("ya");
        list.add("666");
        list.add("sho");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    ```

# List、Set

实现List接口的集合类有以下特点：

- 元素存放是有序的，元素可重复，添加顺序和取出顺序一致
- 元素有其对应的索引，可以通过索引直接去出其中的元素
-  List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 **<实现类有ArrayList，LinkedList，Vector>**
- List可以放null

实现Set接口的集合类有以下特点：

- 存放的元素是无序的，不重复的数据

- 查找元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **<实现类有HashSet,TreeSet>**

## ArrayList

ArrayList是使用数组来存储的，但是它不是线程安全的，在多线程情况下不建议使用。

ArrayList会把元素存放在`transient Object[] elementData;`中

ArrayList如果初始化不指定容量，容量设置为0，后面第一次添加，容量设置为10，后面再次扩容会扩容1.5倍

ArrayList如果初始化指定容量，后面每次扩容，都扩容1.5倍

**ArrayList的最大容量为2\^31-8，因为ArrayList是使用数组来存放元素的，而数组又使用int来当下标，再加上预留一部分空间来存放其他数据，所以是2\^31-8而不是2\^31-1**

ArrayList部分源码：jdk17

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    private static final long serialVersionUID = 8683452581122892189L;
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = new Object[0];
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0];
    transient Object[] elementData;
    private int size;

    //一个参数的构造器，会根据参数初始化ArrayList的elementData的长度，后面需要扩容时直接为1.5倍
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else {
            if (initialCapacity != 0) {
                throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
            }

            this.elementData = EMPTY_ELEMENTDATA;
        }

    }

    //无参构造，它会把elementData的容量设置为0
    //然后第一次添加，会把容量设置为10，后边每次扩容都为1.5倍
    public ArrayList() {
        //注意这个DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这个用来标记ArrayList初始化的时候没有设置参数，用来和初始化的时候设置了参数为0的情况划分
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(Collection<? extends E> c) {
        Object[] a = c.toArray();
        if ((this.size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                this.elementData = a;
            } else {
                this.elementData = Arrays.copyOf(a, this.size, Object[].class);
            }
        } else {
            this.elementData = EMPTY_ELEMENTDATA;
        }

    }
}
```

ArrayList扩容部分的源码：jdk17

```java
private void add(E e, Object[] elementData, int s) {
    //在这里判断，如果this.size等于elementData.length，那么说明容量满了，调用this.grow()方法扩容
    if (s == elementData.length) {
        elementData = this.grow();
    }

    elementData[s] = e;
    this.size = s + 1;
}

public boolean add(E e) {
    //modCount记录被修改的次数
    ++this.modCount;
    this.add(e, this.elementData, this.size);
    return true;
}

private Object[] grow(int minCapacity) {
    int oldCapacity = this.elementData.length;
    if (oldCapacity <= 0 && this.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        //这里是第一次add的时候，elementData为0，就初始化容量为10
        return this.elementData = new Object[Math.max(10, minCapacity)];
    } else {
        //这里把容量进行1.5倍的扩容，newCapacity是获取的新容量，在newLength中会有个容量上限的判断
        int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity >> 1);
        //这里根据新容量扩容，并把原来的数组复制一份过来给新扩容的数组。
        return this.elementData = Arrays.copyOf(this.elementData, newCapacity);
    }
}

private Object[] grow() {
    return this.grow(this.size + 1);
}

//newLength判断上限不超2147483639，即21亿多，2的31次方
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
    int prefLength = oldLength + Math.max(minGrowth, prefGrowth);
    return 0 < prefLength && prefLength <= 2147483639 ? prefLength : hugeLength(oldLength, minGrowth);
}
```

## Vector

Vector和ArrayList类似，只不过他是线程安全的，因为他每个方法都带上了`synchronized`，不过它的效率没有ArrayList高

它的默认初始容量为10，后面每次扩容，都扩容2倍的大小，同时它可以在构造函数中指定每次扩容的大小

`public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable`

部分源码：JDK17

```java
//capacityIncrement用于指定每次扩容的大小
public Vector(int initialCapacity, int capacityIncrement) {
    if (initialCapacity < 0) {
        throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
    } else {
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
}

public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
```

## LinkedList

LinkedList实现了双向链表和双端队列特点

LinkedList线程不安全，没有实现同步

`public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable`

LinkedList的构造方法：JDK17

```java
public LinkedList() {
    this.size = 0;
}

public LinkedList(Collection<? extends E> c) {
    this();
    this.addAll(c);
}
```

LinkedList添加元素的源码：JDK17

```java
public boolean add(E e) {
    this.linkLast(e);
    return true;
}

void linkLast(E e) {
    //获取最后一个节点
    Node<E> l = this.last;
    //创建一个新的节点，这里通过第一个参数指定这个节点的prev，表示该节点的前一个节点
    Node<E> newNode = new Node(l, e, (Node)null);
    this.last = newNode;
    if (l == null) {
        //这里判断添加进来的第一个节点，如果刚刚好是第一个节点，用first指向这个节点
        this.first = newNode;
    } else {
        //如果不是第一个添加进来的节点，那么需要为前一个节点指定它的next。
        l.next = newNode;
    }

    ++this.size;
    ++this.modCount;
}

private static class Node<E> {
    E item;
    Node<E> next;//表示节点的下一个节点
    Node<E> prev;//表示节点的前一个节点

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

remove方法：

- `public E remove()`：删除第一个元素

    remove最终调用unlinkFirst方法删除第一个元素

    ```java
    private E unlinkFirst(Node<E> f) {
        E element = f.item;
        Node<E> next = f.next;
        f.item = null;
        f.next = null;
        this.first = next;
        //如果没有后继节点了，把last设为null，否者把next节点的prev置为null
        if (next == null) {
            this.last = null;
        } else {
            next.prev = null;
        }
    
        --this.size;
        ++this.modCount;
        return element;
    }
    ```

- ` public E remove(int index)`：删除指定下标

    ```java
    public E remove(int index) {
        this.checkElementIndex(index);
        return this.unlink(this.node(index));
    }
    //本函数获取指定下标的node
    Node<E> node(int index) {
        Node x;
        int i;
        //这里进行判断index是否小于size的一半，如果小于，则从first开始遍历，否则从last开始遍历到index
        if (index < this.size >> 1) {
            x = this.first;
    
            for(i = 0; i < index; ++i) {
                x = x.next;
            }
    
            return x;
        } else {
            x = this.last;
    
            for(i = this.size - 1; i > index; --i) {
                x = x.prev;
            }
    
            return x;
        }
    }
    //本函数负责把一个node节点删除
    E unlink(Node<E> x) {
        E element = x.item;
        Node<E> next = x.next;
        Node<E> prev = x.prev;
        if (prev == null) {
            this.first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }
    
        if (next == null) {
            this.last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }
    
        x.item = null;
        --this.size;
        ++this.modCount;
        return element;
    }
    ```

- `public boolean remove(Object o)`：删除指定对象

<img src="images/image-20230623214746830.png" alt="image-20230623214746830" style="zoom:80%;" />

## HashSet

