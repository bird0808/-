# 反射

java给我们提供了一套API,使用这套API我们可以在运行的时候动态的获取指定对象所属的类,创建**运行时**类的对象,调用、查看类的所有内容(属性,方法等)

## 反射优缺点

优点：

- 提高了Java程序的灵活性和扩展性，降低了耦合性，提高自适应能力

- 允许程序创建和控制任何类的对象，无需提前硬编码目标类

缺点：

- 反射的性能较低。

- 反射机制主要应用在对灵活性和扩展性要求很高的系统框架上
    反射会模糊程序内部逻辑，可读性较差。

# 反射获取Class的实例

```java

//直接通过.class获取,要求编译期间已知类型,性能最高
Class clazz1= Person.class;

//已经有了某个类的实例对象,通过实例的getClass()方法获取Class对象
Class clazz2=person.getClass();

//已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
Class clazz3=Class.forName("org.example.Person");//使用最多的方式
```

# 反射获取类的构造器

通过反射,即便是私有的构造器方法,一样可以获取

```java
//直接通过.class获取,要求编译期间已知类型,性能最高
Class clazz1= Person.class;
//获取构造器
Constructor<?> constructor = clazz1.getDeclaredConstructor();
//设置可以私有的构造器
constructor.setAccessible(true);
//获取类的实例
Object person1=constructor.newInstance();
System.out.println(person1);
```

通过指定参数列表,可以获取指定参数的构造器,下面就获取了参数为String和int的构造器

```java
//直接通过.class获取,要求编译期间已知类型,性能最高
Class clazz1= Person.class;
//获取构造器
Constructor<?> constructor = clazz1.getDeclaredConstructor(String.class,int.class);
//设置可以私有的构造器
constructor.setAccessible(true);
//获取类的实例
Object person1=constructor.newInstance("小红",18);
System.out.println(person1);
```

